use std::env;
use std::path::PathBuf;

fn main() {
    // Skip when building docs
    if env::var("DOCS_RS").is_ok() {
        return;
    }

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    // Generate C header file
    generate_header(&crate_dir);

    // Setup linking to prebuilt libraries
    setup_library_linking(&crate_dir);

    // Inform Cargo to rerun if source changes
    println!("cargo:rerun-if-changed=src");
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=../native");
}

fn generate_header(crate_dir: &str) {
    let include_dir = PathBuf::from(crate_dir)
        .parent()
        .expect("Failed to get parent directory")
        .join("include");

    // Create include directory if it doesn't exist
    std::fs::create_dir_all(&include_dir).expect("Failed to create include directory");

    let header_path = include_dir.join("extractous.h");

    // Generate C header using cbindgen
    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_header(
            "/* Extractous Go FFI - Auto-generated by cbindgen */\n/* DO NOT EDIT MANUALLY */",
        )
        .with_include_guard("EXTRACTOUS_FFI_H")
        .with_pragma_once(true)
        .with_documentation(true)
        .with_cpp_compat(true)
        .with_tab_width(4)
        .with_no_includes()
        .with_sys_include("stdint.h")
        .with_sys_include("stdbool.h")
        .with_sys_include("stdlib.h")
        .generate()
        .expect("Unable to generate C bindings")
        .write_to_file(&header_path);

    println!(
        "cargo:warning=Generated C header at: {}",
        header_path.display()
    );
}

fn setup_library_linking(crate_dir: &str) {
    let root_dir = PathBuf::from(crate_dir).parent().unwrap().to_path_buf();

    // Detect platform and architecture
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap();
    let target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap();

    // Determine the native library directory based on platform
    let platform_dir = match (target_os.as_str(), target_arch.as_str()) {
        ("linux", "x86_64") => "linux_amd64",
        ("linux", "aarch64") => "linux_arm64",
        ("macos", "x86_64") => "darwin_amd64",
        ("macos", "aarch64") => "darwin_arm64",
        ("windows", "x86_64") => "windows_amd64",
        _ => panic!("Unsupported platform: {} {}", target_os, target_arch),
    };

    let native_libs_dir = root_dir.join("native").join(platform_dir);

    // Check if the native library directory exists
    if !native_libs_dir.exists() {
        eprintln!("\n\n=================================================================");
        eprintln!("ERROR: Native libraries not found!");
        eprintln!("=================================================================");
        eprintln!("Expected directory: {}", native_libs_dir.display());
        eprintln!("\nPlease extract the prebuilt libraries from the Python wheel:");
        eprintln!("  1. Download the appropriate wheel for your platform from:");
        eprintln!("     https://pypi.org/project/extractous/#files");
        eprintln!("  2. Extract the wheel (it's a zip file)");
        eprintln!(
            "  3. Copy the .so/.dylib/.dll files to: {}",
            native_libs_dir.display()
        );
        eprintln!("\nRequired files:");
        eprintln!("  - libtika_native.so (Linux)");
        eprintln!("  - libtika_native.dylib (macOS)");
        eprintln!("  - libtika_native.dll (Windows)");
        eprintln!("  - All dependent JVM libraries (java.dll, jvm.dll, etc.)");
        eprintln!("=================================================================\n");
        panic!(
            "Native libraries not found at: {}",
            native_libs_dir.display()
        );
    }

    println!(
        "cargo:warning=Using native libraries from: {}",
        native_libs_dir.display()
    );

    // Tell cargo where to find the libraries
    println!(
        "cargo:rustc-link-search=native={}",
        native_libs_dir.display()
    );

    // Tell cargo to link against libtika_native
    // On Windows, the library is named libtika_native.dll, on Unix it's libtika_native.so/.dylib
    let lib_name = if target_os == "windows" {
        "libtika_native" // Windows uses the full name with prefix
    } else {
        "tika_native" // Unix strips the 'lib' prefix
    };

    println!("cargo:rustc-link-lib=dylib={}", lib_name);

    // Set rpath for runtime library loading
    if target_os == "linux" {
        println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
    } else if target_os == "macos" {
        println!("cargo:rustc-link-arg=-Wl,-rpath,@loader_path");
    }
}
