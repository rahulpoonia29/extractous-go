use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    // Skip when building docs
    if env::var("DOCS_RS").is_ok() {
        return;
    }

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    // Step 1: Generate C header file
    generate_header(&crate_dir);
    link_prebuilt_libs();

    // Step 2: Set RPATH for dynamic library loading
    set_rpath();

    // Step 3: Inform Cargo to rerun if source changes
    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_header(crate_dir: &str) {
    let include_dir = PathBuf::from(crate_dir)
        .parent()
        .expect("Failed to get parent directory")
        .join("include");

    // Create include directory if it doesn't exist
    fs::create_dir_all(&include_dir).expect("Failed to create include directory");

    let header_path = include_dir.join("extractous.h");

    // Generate C header using cbindgen
    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_header(
            "/* Extractous Go FFI - Auto-generated by cbindgen */\n/* DO NOT EDIT MANUALLY */",
        )
        .with_include_guard("EXTRACTOUS_FFI_H")
        .with_pragma_once(true)
        .with_documentation(true)
        .with_cpp_compat(true)
        .with_tab_width(4)
        .generate()
        .expect("Unable to generate C bindings")
        .write_to_file(&header_path);

    println!(
        "cargo:warning=Generated C header at {}",
        header_path.display()
    );
}

fn link_prebuilt_libs() {
    let manifest = env::var("CARGO_MANIFEST_DIR").unwrap();
    let prebuilt_root = PathBuf::from(&manifest).parent().unwrap().join("native");

    let target = env::var("TARGET").unwrap();
    let plat = if target.contains("x86_64-unknown-linux") {
        "linux_amd64"
    } else if target.contains("aarch64-unknown-linux") {
        "linux_arm64"
    } else if target.contains("x86_64-apple-darwin") {
        "darwin_amd64"
    } else if target.contains("aarch64-apple-darwin") {
        "darwin_arm64"
    } else if target.contains("x86_64-pc-windows") {
        "windows_amd64"
    } else {
        panic!("Unsupported target: {}", target);
    };

    let libdir = prebuilt_root.join(plat);
    if !libdir.exists() {
        panic!(
            "Prebuilt libs not found at {}. Run scripts/extract-wheels.sh",
            libdir.display()
        );
    }

    // Tell rustc/ld where to find libtika_native.* and friends
    println!("cargo:rustc-link-search=native={}", libdir.display());
    println!("cargo:rustc-link-lib=dylib=tika_native"); // links -ltika_native
}

fn set_rpath() {
    let target = env::var("TARGET").unwrap();

    // Set RPATH so the built library can find other libraries in the same directory
    if target.contains("linux") {
        // $ORIGIN means "directory containing this library"
        println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
    } else if target.contains("darwin") {
        // @loader_path is macOS equivalent of $ORIGIN
        println!("cargo:rustc-link-arg=-Wl,-rpath,@loader_path");
    }
    // Windows doesn't need RPATH - uses DLL search path
}
