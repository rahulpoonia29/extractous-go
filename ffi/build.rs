use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    // Skip when building docs
    if env::var("DOCS_RS").is_ok() {
        return;
    }

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let root_dir = PathBuf::from(&manifest_dir)
        .parent()
        .expect("Failed to get parent directory")
        .to_path_buf();

    println!("cargo:warning=Building extractous-ffi");

    // 1. Generate C header
    generate_header(&manifest_dir, &root_dir);

    // 2. Link to prebuilt native libraries
    link_native_libraries(&root_dir);

    // 3. Set RPATH for runtime library discovery
    set_rpath();

    // Rerun triggers
    println!("cargo:rerun-if-changed=src");
    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_header(crate_dir: &str, root_dir: &PathBuf) {
    let include_dir = root_dir.join("include");
    fs::create_dir_all(&include_dir).expect("Failed to create include directory");
    let header_path = include_dir.join("extractous.h");

    match cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_header("/* Extractous Go FFI - Auto-generated by cbindgen */")
        .with_include_guard("EXTRACTOUS_FFI_H")
        .with_pragma_once(true)
        .with_documentation(true)
        .with_cpp_compat(true)
        .with_tab_width(4)
        .with_line_length(100)
        .with_sys_include("stdint.h")
        .with_sys_include("stdbool.h")
        .with_sys_include("stdlib.h")
        .generate()
    {
        Ok(bindings) => {
            bindings.write_to_file(&header_path);
            println!("cargo:warning=Generated header: {}", header_path.display());
        }
        Err(e) => {
            println!("cargo:warning=Failed to generate header: {:?}", e);
        }
    }
}

fn link_native_libraries(root_dir: &PathBuf) {
    let target = env::var("TARGET").unwrap();

    // Map Rust target triple to our platform naming
    let platform_dir = match target.as_str() {
        "x86_64-unknown-linux-gnu" => "linux_amd64",
        "x86_64-apple-darwin" => "darwin_amd64",
        "aarch64-apple-darwin" => "darwin_arm64",
        "x86_64-pc-windows-gnu" | "x86_64-pc-windows-msvc" => "windows_amd64",
        _ => {
            println!("cargo:warning=Unsupported target: {}", target);
            println!("cargo:warning=Skipping native library linking");
            return;
        }
    };

    let native_dir = root_dir.join("native").join(platform_dir);

    if !native_dir.exists() {
        panic!(
            "\n\n================================================================\n\
             ERROR: Native libraries not found for target: {}\n\
             ================================================================\n\
             Expected at: {}\n\n\
             Please run: make extract-wheels\n\
             ================================================================\n",
            target,
            native_dir.display()
        );
    }

    println!("cargo:rustc-link-search=native={}", native_dir.display());
    println!("cargo:rustc-link-lib=dylib=tika_native");
    println!(
        "cargo:warning=Linking to libtika_native from {}",
        native_dir.display()
    );
}

fn set_rpath() {
    let target = env::var("TARGET").unwrap();

    if target.contains("linux") {
        println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
        println!("cargo:rustc-link-arg=-Wl,--enable-new-dtags");
    } else if target.contains("darwin") {
        println!("cargo:rustc-link-arg=-Wl,-rpath,@loader_path");
    }
    // Windows searches current directory by default
}
