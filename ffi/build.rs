use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    if env::var("DOCS_RS").is_ok() {
        return;
    }

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let root_dir = PathBuf::from(&manifest_dir);

    println!("cargo:warning=Building extractous-ffi");

    // 1. Generate C header
    generate_header(&manifest_dir, &root_dir);

    // 2. Set RPATH for runtime library discovery
    set_rpath();

    // Rerun triggers
    println!("cargo:rerun-if-changed=src");
    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_header(crate_dir: &str, root_dir: &PathBuf) {
    let include_dir = root_dir.join("include");
    fs::create_dir_all(&include_dir).expect("Failed to create include directory");
    let header_path = include_dir.join("extractous.h");

    match cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_header("/* Extractous FFI - Auto-generated by cbindgen */")
        .with_include_guard("EXTRACTOUS_FFI_H")
        .with_pragma_once(true)
        .with_documentation(true)
        .with_cpp_compat(true)
        .generate()
    {
        Ok(bindings) => {
            bindings.write_to_file(&header_path);
            println!("cargo:warning=Generated header: {}", header_path.display());
        }
        Err(e) => {
            println!("cargo:warning=Failed to generate header: {:?}", e);
        }
    }
}

fn set_rpath() {
    let target = env::var("TARGET").unwrap();

    if target.contains("linux") {
        println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
        println!("cargo:rustc-link-arg=-Wl,--enable-new-dtags");
    } else if target.contains("darwin") {
        println!("cargo:rustc-link-arg=-Wl,-rpath,@loader_path");
    }
}